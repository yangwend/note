## 单行失焦与页面保存/提交同时触发的方案

主要处理失焦和保存/提交都是走异步的场景。

1、仅失焦，走失焦异步函数
2、仅提交，走提交异步函数
3、失焦和提交同时触发，先走失焦异步函数，失焦异步函数成功后再走提交异步函数
4、单行数据更新时，**表格增加 loading 展示(不要加全局 loading，不然只会触发失焦不触发提交按钮的事件)**，同时只改本地数据，不需要调后端接口更新数据
5、失焦时可以做数据对比，更新了才调接口更新

### 方案 1（适用于 2 个逻辑在同一个页面的场景）

1、table 单行数据，光标聚焦时，记录当前聚焦的行数据
2、table 单行数据失焦时，异步函数处理后移除当前聚焦的行数据
3、失焦加定时器延时
4、输入数据，点击保存/提交按钮时，先会执行失焦，再执行保存。然而由于失焦做了定时器延时，所以执行保存逻辑时，先更新 flag 为 true，然后再执行 blur，再重置页面的 flag 和 聚焦的行数据，再执行保存

```ts
let flag = false;
let focusIndex = -1;

const handleFocus = (record) => {
  // 光标聚焦时，记录当前聚焦的行数据
  focusIndex = record.index;
};

const handleBlur = () => {
  // 失焦加定时器延时
  setTimeout(() => {
    if (flag) {
      // flag 为 true，说明是点击保存/提交，不执行 blur 异步事件，直接在保存/提交逻辑中处理 blur
      return;
    }
    // blur 异步事件

    // blur 异步事件成功后移除聚焦的行数据
    focusIndex = -1;
  }, 50);
};

const handleSubmit = () => {
  if (focusIndex > -1) {
    // 说明失焦和提交同时触发，更新 flag，然后执行blur事件
    flag = true;
    // blur 异步事件

    // blur 异步事件成功后移除聚焦的行数据
    focusIndex = -1;
    // blur 异步事件成功后更新 flag
    flag = false;
  } else {
    // 直接点击的保存/提交，直接走保存/提交逻辑
  }

  // 保存/提交逻辑
};
```

### 方案 2（暂时不使用，但是也是可用的）

1、table 单行数据失焦时设置 loading
2、保存/提交时，获取到上面的 loading，setInterval 做轮询，直到 loading 为 false，再执行保存/提交逻辑

```ts
let loading = false;
const handleBlur = () => {
  loading = true;
  // 执行 blur 异步事件
  loading = false;
};

let loading1 = false;
const sleep = (ms: number) => {
  loading1 = true;
  return new Promise((resolve) => {
    let timer = setInterval(() => {
      if (!loading) {
        clearInterval(timer);
        loading1 = false;
        resolve(true);
      }
    }, 50);
  });
};

const handleSubmit = async () => {
  await sleep();

  // 保存/提交逻辑
};

// loading 控制table的loading
// loading1 控制保存/提交的loading，再加上保存/提交逻辑自己的loading
```

### 方案 3（推荐使用该方案）

使用队列来实现。

```ts
// 公共的队列类
export default class Queue {
  public currentTask: Generator<Promise<any>, void, unknown> | null = null;

  private taskList: Promise<any>[] = [];

  public addQuery<T>(query: Promise<T>): void {
    this.taskList.push(query);
    this.currentTask ??= this.createTask();
  }

  public *createTask(): Generator<Promise<any>, void, unknown> {
    for (let i = 0; i < this.taskList.length; i++) {
      yield this.taskList[i];
    }
    this.taskList = [];
  }

  public runNext(): Promise<any> | undefined | void {
    this.currentTask ??= this.createTask();
    return this.currentTask.next().value;
  }

  public async runToDone(): Promise<void> {
    this.currentTask ??= this.createTask();
    while (this.currentTask) {
      const task = this.currentTask.next();
      await task.value;
      if (task.done) {
        break;
      }
    }
    this.currentTask = null;
  }
}
```

```ts
// 使用
const queue = new Queue();

const handleBlur = () => {
  queue.addQuery(
    new Promise((resolve) => {
      // 执行 blur 异步事件
      resolve(true);
    })
  );
};

const handleSubmit = async () => {
  await queue.runToDone();

  // 保存/提交逻辑
};
```
